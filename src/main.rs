use rusttype::*;fn main() {println!("VS 1; SP 1;");let q=["use rusttype::*;fn main() {println!(\"VS 1; SP 1;\");let q=[","];let msg=format!(\"{}{:?},{:?}{}\", q[0], q[0], q[1], q[1]);let mut fd=Vec::new();let mut file=std::fs::File::open(\"./inconsolata.ttf\").unwrap();std::io::Read::read_to_end(&mut file, &mut fd).unwrap();let line_count=msg.len() / 90 + 1;for no in 0..line_count {let line=&msg[(no*90)..(no*90 + 90).min(msg.len())];let glyphs: Vec<PositionedGlyph<\'_>>=FontCollection::from_bytes(&fd).unwrap().into_font().unwrap().layout(line,Scale::uniform(240.),Point {x:0.,y:(7650-no*240-200) as f32},).collect();for glyph in glyphs {if let Some(contours)=glyph.shape() {for contour in contours {let mut res=vec![];for segment in contour.segments {match segment {Segment::Line(line)=>{res.push(line.p[0]); res.push(line.p[1])},Segment::Curve(c)=>{let p=c.p;for i in 0..3 {let t=i as f32*0.5;let x=(1.0-t)*(1.0-t)*p[0].x+2.0*(1.0-t)*t*p[1].x+t*t*p[2].x;let y=(1.0-t)*(1.0-t)*p[0].y+2.0*(1.0-t)*t*p[1].y+t*t*p[2].y;res.push(Point{x,y});}}}}let mut points=vec![];for item in res {if Some(&item)!=points.last() {points.push(item);}}if points.len()!=0 {println!(\"PU;\");println!(\"PA {}, {};\", points[0].x as i64, points[0].y as i64);println!(\"PD;\");for p in points {println!(\"PA {}, {};\", p.x as i64, p.y as i64);}println!(\"PU;\");}}}}}}"];let msg=format!("{}{:?},{:?}{}", q[0], q[0], q[1], q[1]);let mut fd=Vec::new();let mut file=std::fs::File::open("./inconsolata.ttf").unwrap();std::io::Read::read_to_end(&mut file, &mut fd).unwrap();let line_count=msg.len() / 90 + 1;for no in 0..line_count {let line=&msg[(no*90)..(no*90 + 90).min(msg.len())];let glyphs: Vec<PositionedGlyph<'_>>=FontCollection::from_bytes(&fd).unwrap().into_font().unwrap().layout(line,Scale::uniform(240.),Point {x:0.,y:(7650-no*240-200) as f32},).collect();for glyph in glyphs {if let Some(contours)=glyph.shape() {for contour in contours {let mut res=vec![];for segment in contour.segments {match segment {Segment::Line(line)=>{res.push(line.p[0]); res.push(line.p[1])},Segment::Curve(c)=>{let p=c.p;for i in 0..3 {let t=i as f32*0.5;let x=(1.0-t)*(1.0-t)*p[0].x+2.0*(1.0-t)*t*p[1].x+t*t*p[2].x;let y=(1.0-t)*(1.0-t)*p[0].y+2.0*(1.0-t)*t*p[1].y+t*t*p[2].y;res.push(Point{x,y});}}}}let mut points=vec![];for item in res {if Some(&item)!=points.last() {points.push(item);}}if points.len()!=0 {println!("PU;");println!("PA {}, {};", points[0].x as i64, points[0].y as i64);println!("PD;");for p in points {println!("PA {}, {};", p.x as i64, p.y as i64);}println!("PU;");}}}}}}